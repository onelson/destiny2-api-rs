/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// DestinyEntitiesItemsDestinyItemComponent : The base item component, filled with properties that are generally useful to know in any item request or that don't feel worthwhile to put in their own component.

#[derive(Debug, Serialize, Deserialize)]
pub struct DestinyEntitiesItemsDestinyItemComponent {
  /// The identifier for the item's definition, which is where most of the useful static information for the item can be found.
  #[serde(rename = "itemHash")]
  item_hash: Option<i32>,
  /// If the item is instanced, it will have an instance ID. Lack of an instance ID implies that the item has no distinct local qualities aside from stack size.
  #[serde(rename = "itemInstanceId")]
  item_instance_id: Option<i64>,
  /// The quantity of the item in this stack. Note that Instanced items cannot stack. If an instanced item, this value will always be 1 (as the stack has exactly one item in it)
  #[serde(rename = "quantity")]
  quantity: Option<i32>,
  /// If the item is bound to a location, it will be specified in this enum.
  #[serde(rename = "bindStatus")]
  bind_status: Option<Object>,
  /// An easy reference for where the item is located. Redundant if you got the item from an Inventory, but useful when making detail calls on specific items.
  #[serde(rename = "location")]
  location: Option<Object>,
  /// The hash identifier for the specific inventory bucket in which the item is located.
  #[serde(rename = "bucketHash")]
  bucket_hash: Option<i32>,
  /// If there is a known error state that would cause this item to not be transferable, this Flags enum will indicate all of those error states. Otherwise, it will be 0 (CanTransfer).
  #[serde(rename = "transferStatus")]
  transfer_status: Option<Object>,
  /// If the item can be locked, this will indicate that state.
  #[serde(rename = "lockable")]
  lockable: Option<bool>,
  /// A flags enumeration indicating the states of the item: whether it's tracked or locked for example.
  #[serde(rename = "state")]
  state: Option<Object>
}

impl DestinyEntitiesItemsDestinyItemComponent {
  /// The base item component, filled with properties that are generally useful to know in any item request or that don't feel worthwhile to put in their own component.
  pub fn new() -> DestinyEntitiesItemsDestinyItemComponent {
    DestinyEntitiesItemsDestinyItemComponent {
      item_hash: None,
      item_instance_id: None,
      quantity: None,
      bind_status: None,
      location: None,
      bucket_hash: None,
      transfer_status: None,
      lockable: None,
      state: None
    }
  }

  pub fn set_item_hash(&mut self, item_hash: i32) {
    self.item_hash = Some(item_hash);
  }

  pub fn with_item_hash(mut self, item_hash: i32) -> DestinyEntitiesItemsDestinyItemComponent {
    self.item_hash = Some(item_hash);
    self
  }

  pub fn item_hash(&self) -> Option<&i32> {
    self.item_hash.as_ref()
  }

  pub fn reset_item_hash(&mut self) {
    self.item_hash = None;
  }

  pub fn set_item_instance_id(&mut self, item_instance_id: i64) {
    self.item_instance_id = Some(item_instance_id);
  }

  pub fn with_item_instance_id(mut self, item_instance_id: i64) -> DestinyEntitiesItemsDestinyItemComponent {
    self.item_instance_id = Some(item_instance_id);
    self
  }

  pub fn item_instance_id(&self) -> Option<&i64> {
    self.item_instance_id.as_ref()
  }

  pub fn reset_item_instance_id(&mut self) {
    self.item_instance_id = None;
  }

  pub fn set_quantity(&mut self, quantity: i32) {
    self.quantity = Some(quantity);
  }

  pub fn with_quantity(mut self, quantity: i32) -> DestinyEntitiesItemsDestinyItemComponent {
    self.quantity = Some(quantity);
    self
  }

  pub fn quantity(&self) -> Option<&i32> {
    self.quantity.as_ref()
  }

  pub fn reset_quantity(&mut self) {
    self.quantity = None;
  }

  pub fn set_bind_status(&mut self, bind_status: Object) {
    self.bind_status = Some(bind_status);
  }

  pub fn with_bind_status(mut self, bind_status: Object) -> DestinyEntitiesItemsDestinyItemComponent {
    self.bind_status = Some(bind_status);
    self
  }

  pub fn bind_status(&self) -> Option<&Object> {
    self.bind_status.as_ref()
  }

  pub fn reset_bind_status(&mut self) {
    self.bind_status = None;
  }

  pub fn set_location(&mut self, location: Object) {
    self.location = Some(location);
  }

  pub fn with_location(mut self, location: Object) -> DestinyEntitiesItemsDestinyItemComponent {
    self.location = Some(location);
    self
  }

  pub fn location(&self) -> Option<&Object> {
    self.location.as_ref()
  }

  pub fn reset_location(&mut self) {
    self.location = None;
  }

  pub fn set_bucket_hash(&mut self, bucket_hash: i32) {
    self.bucket_hash = Some(bucket_hash);
  }

  pub fn with_bucket_hash(mut self, bucket_hash: i32) -> DestinyEntitiesItemsDestinyItemComponent {
    self.bucket_hash = Some(bucket_hash);
    self
  }

  pub fn bucket_hash(&self) -> Option<&i32> {
    self.bucket_hash.as_ref()
  }

  pub fn reset_bucket_hash(&mut self) {
    self.bucket_hash = None;
  }

  pub fn set_transfer_status(&mut self, transfer_status: Object) {
    self.transfer_status = Some(transfer_status);
  }

  pub fn with_transfer_status(mut self, transfer_status: Object) -> DestinyEntitiesItemsDestinyItemComponent {
    self.transfer_status = Some(transfer_status);
    self
  }

  pub fn transfer_status(&self) -> Option<&Object> {
    self.transfer_status.as_ref()
  }

  pub fn reset_transfer_status(&mut self) {
    self.transfer_status = None;
  }

  pub fn set_lockable(&mut self, lockable: bool) {
    self.lockable = Some(lockable);
  }

  pub fn with_lockable(mut self, lockable: bool) -> DestinyEntitiesItemsDestinyItemComponent {
    self.lockable = Some(lockable);
    self
  }

  pub fn lockable(&self) -> Option<&bool> {
    self.lockable.as_ref()
  }

  pub fn reset_lockable(&mut self) {
    self.lockable = None;
  }

  pub fn set_state(&mut self, state: Object) {
    self.state = Some(state);
  }

  pub fn with_state(mut self, state: Object) -> DestinyEntitiesItemsDestinyItemComponent {
    self.state = Some(state);
    self
  }

  pub fn state(&self) -> Option<&Object> {
    self.state.as_ref()
  }

  pub fn reset_state(&mut self) {
    self.state = None;
  }

}



