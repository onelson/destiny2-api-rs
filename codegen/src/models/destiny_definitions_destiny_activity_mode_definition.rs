/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[derive(Debug, Serialize, Deserialize)]
pub struct DestinyDefinitionsDestinyActivityModeDefinition {
  #[serde(rename = "displayProperties")]
  display_properties: Option<::models::DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition>,
  #[serde(rename = "pgcrImage")]
  pgcr_image: Option<String>,
  #[serde(rename = "modeType")]
  mode_type: Option<::models::DestinyHistoricalStatsDefinitionsDestinyActivityModeType>,
  #[serde(rename = "activityModeCategory")]
  activity_mode_category: Option<::models::DestinyDestinyActivityModeCategory>,
  #[serde(rename = "isTeamBased")]
  is_team_based: Option<bool>,
  #[serde(rename = "isAggregateMode")]
  is_aggregate_mode: Option<bool>,
  #[serde(rename = "parentHashes")]
  parent_hashes: Option<Vec<i32>>,
  #[serde(rename = "friendlyName")]
  friendly_name: Option<String>,
  #[serde(rename = "activityModeMappings")]
  activity_mode_mappings: Option<::std::collections::HashMap<String, ::models::DestinyHistoricalStatsDefinitionsDestinyActivityModeType>>,
  /// If FALSE, we want to ignore this type when we're showing activity modes in BNet UI. It will still be returned in case 3rd parties want to use it for any purpose.
  #[serde(rename = "display")]
  display: Option<bool>,
  /// The relative ordering of activity modes.
  #[serde(rename = "order")]
  order: Option<i32>,
  /// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
  #[serde(rename = "hash")]
  hash: Option<i32>,
  /// The index of the entity as it was found in the investment tables.
  #[serde(rename = "index")]
  index: Option<i32>,
  /// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
  #[serde(rename = "redacted")]
  redacted: Option<bool>
}

impl DestinyDefinitionsDestinyActivityModeDefinition {
  pub fn new() -> DestinyDefinitionsDestinyActivityModeDefinition {
    DestinyDefinitionsDestinyActivityModeDefinition {
      display_properties: None,
      pgcr_image: None,
      mode_type: None,
      activity_mode_category: None,
      is_team_based: None,
      is_aggregate_mode: None,
      parent_hashes: None,
      friendly_name: None,
      activity_mode_mappings: None,
      display: None,
      order: None,
      hash: None,
      index: None,
      redacted: None
    }
  }

  pub fn set_display_properties(&mut self, display_properties: ::models::DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition) {
    self.display_properties = Some(display_properties);
  }

  pub fn with_display_properties(mut self, display_properties: ::models::DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.display_properties = Some(display_properties);
    self
  }

  pub fn display_properties(&self) -> Option<&::models::DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition> {
    self.display_properties.as_ref()
  }

  pub fn reset_display_properties(&mut self) {
    self.display_properties = None;
  }

  pub fn set_pgcr_image(&mut self, pgcr_image: String) {
    self.pgcr_image = Some(pgcr_image);
  }

  pub fn with_pgcr_image(mut self, pgcr_image: String) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.pgcr_image = Some(pgcr_image);
    self
  }

  pub fn pgcr_image(&self) -> Option<&String> {
    self.pgcr_image.as_ref()
  }

  pub fn reset_pgcr_image(&mut self) {
    self.pgcr_image = None;
  }

  pub fn set_mode_type(&mut self, mode_type: ::models::DestinyHistoricalStatsDefinitionsDestinyActivityModeType) {
    self.mode_type = Some(mode_type);
  }

  pub fn with_mode_type(mut self, mode_type: ::models::DestinyHistoricalStatsDefinitionsDestinyActivityModeType) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.mode_type = Some(mode_type);
    self
  }

  pub fn mode_type(&self) -> Option<&::models::DestinyHistoricalStatsDefinitionsDestinyActivityModeType> {
    self.mode_type.as_ref()
  }

  pub fn reset_mode_type(&mut self) {
    self.mode_type = None;
  }

  pub fn set_activity_mode_category(&mut self, activity_mode_category: ::models::DestinyDestinyActivityModeCategory) {
    self.activity_mode_category = Some(activity_mode_category);
  }

  pub fn with_activity_mode_category(mut self, activity_mode_category: ::models::DestinyDestinyActivityModeCategory) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.activity_mode_category = Some(activity_mode_category);
    self
  }

  pub fn activity_mode_category(&self) -> Option<&::models::DestinyDestinyActivityModeCategory> {
    self.activity_mode_category.as_ref()
  }

  pub fn reset_activity_mode_category(&mut self) {
    self.activity_mode_category = None;
  }

  pub fn set_is_team_based(&mut self, is_team_based: bool) {
    self.is_team_based = Some(is_team_based);
  }

  pub fn with_is_team_based(mut self, is_team_based: bool) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.is_team_based = Some(is_team_based);
    self
  }

  pub fn is_team_based(&self) -> Option<&bool> {
    self.is_team_based.as_ref()
  }

  pub fn reset_is_team_based(&mut self) {
    self.is_team_based = None;
  }

  pub fn set_is_aggregate_mode(&mut self, is_aggregate_mode: bool) {
    self.is_aggregate_mode = Some(is_aggregate_mode);
  }

  pub fn with_is_aggregate_mode(mut self, is_aggregate_mode: bool) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.is_aggregate_mode = Some(is_aggregate_mode);
    self
  }

  pub fn is_aggregate_mode(&self) -> Option<&bool> {
    self.is_aggregate_mode.as_ref()
  }

  pub fn reset_is_aggregate_mode(&mut self) {
    self.is_aggregate_mode = None;
  }

  pub fn set_parent_hashes(&mut self, parent_hashes: Vec<i32>) {
    self.parent_hashes = Some(parent_hashes);
  }

  pub fn with_parent_hashes(mut self, parent_hashes: Vec<i32>) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.parent_hashes = Some(parent_hashes);
    self
  }

  pub fn parent_hashes(&self) -> Option<&Vec<i32>> {
    self.parent_hashes.as_ref()
  }

  pub fn reset_parent_hashes(&mut self) {
    self.parent_hashes = None;
  }

  pub fn set_friendly_name(&mut self, friendly_name: String) {
    self.friendly_name = Some(friendly_name);
  }

  pub fn with_friendly_name(mut self, friendly_name: String) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.friendly_name = Some(friendly_name);
    self
  }

  pub fn friendly_name(&self) -> Option<&String> {
    self.friendly_name.as_ref()
  }

  pub fn reset_friendly_name(&mut self) {
    self.friendly_name = None;
  }

  pub fn set_activity_mode_mappings(&mut self, activity_mode_mappings: ::std::collections::HashMap<String, ::models::DestinyHistoricalStatsDefinitionsDestinyActivityModeType>) {
    self.activity_mode_mappings = Some(activity_mode_mappings);
  }

  pub fn with_activity_mode_mappings(mut self, activity_mode_mappings: ::std::collections::HashMap<String, ::models::DestinyHistoricalStatsDefinitionsDestinyActivityModeType>) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.activity_mode_mappings = Some(activity_mode_mappings);
    self
  }

  pub fn activity_mode_mappings(&self) -> Option<&::std::collections::HashMap<String, ::models::DestinyHistoricalStatsDefinitionsDestinyActivityModeType>> {
    self.activity_mode_mappings.as_ref()
  }

  pub fn reset_activity_mode_mappings(&mut self) {
    self.activity_mode_mappings = None;
  }

  pub fn set_display(&mut self, display: bool) {
    self.display = Some(display);
  }

  pub fn with_display(mut self, display: bool) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.display = Some(display);
    self
  }

  pub fn display(&self) -> Option<&bool> {
    self.display.as_ref()
  }

  pub fn reset_display(&mut self) {
    self.display = None;
  }

  pub fn set_order(&mut self, order: i32) {
    self.order = Some(order);
  }

  pub fn with_order(mut self, order: i32) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.order = Some(order);
    self
  }

  pub fn order(&self) -> Option<&i32> {
    self.order.as_ref()
  }

  pub fn reset_order(&mut self) {
    self.order = None;
  }

  pub fn set_hash(&mut self, hash: i32) {
    self.hash = Some(hash);
  }

  pub fn with_hash(mut self, hash: i32) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.hash = Some(hash);
    self
  }

  pub fn hash(&self) -> Option<&i32> {
    self.hash.as_ref()
  }

  pub fn reset_hash(&mut self) {
    self.hash = None;
  }

  pub fn set_index(&mut self, index: i32) {
    self.index = Some(index);
  }

  pub fn with_index(mut self, index: i32) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.index = Some(index);
    self
  }

  pub fn index(&self) -> Option<&i32> {
    self.index.as_ref()
  }

  pub fn reset_index(&mut self) {
    self.index = None;
  }

  pub fn set_redacted(&mut self, redacted: bool) {
    self.redacted = Some(redacted);
  }

  pub fn with_redacted(mut self, redacted: bool) -> DestinyDefinitionsDestinyActivityModeDefinition {
    self.redacted = Some(redacted);
    self
  }

  pub fn redacted(&self) -> Option<&bool> {
    self.redacted.as_ref()
  }

  pub fn reset_redacted(&mut self) {
    self.redacted = None;
  }

}



