/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[derive(Debug, Serialize, Deserialize)]
pub struct DestinyHistoricalStatsDestinyHistoricalStatsActivity {
  /// Hash ID that can be looked up in the DestinyActivityTable.
  #[serde(rename = "referenceId")]
  reference_id: Option<i32>,
  #[serde(rename = "directorActivityHash")]
  director_activity_hash: Option<i32>,
  /// This value can be used to get additional data about this activity such as who else was playing.
  #[serde(rename = "instanceId")]
  instance_id: Option<i64>,
  /// Indicates the game mode of the activity.
  #[serde(rename = "mode")]
  mode: Option<Object>,
  #[serde(rename = "modes")]
  modes: Option<Vec<::models::DestinyHistoricalStatsDefinitionsDestinyActivityModeType>>,
  /// Whether or not the match was a private match.
  #[serde(rename = "isPrivate")]
  is_private: Option<bool>
}

impl DestinyHistoricalStatsDestinyHistoricalStatsActivity {
  pub fn new() -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    DestinyHistoricalStatsDestinyHistoricalStatsActivity {
      reference_id: None,
      director_activity_hash: None,
      instance_id: None,
      mode: None,
      modes: None,
      is_private: None
    }
  }

  pub fn set_reference_id(&mut self, reference_id: i32) {
    self.reference_id = Some(reference_id);
  }

  pub fn with_reference_id(mut self, reference_id: i32) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.reference_id = Some(reference_id);
    self
  }

  pub fn reference_id(&self) -> Option<&i32> {
    self.reference_id.as_ref()
  }

  pub fn reset_reference_id(&mut self) {
    self.reference_id = None;
  }

  pub fn set_director_activity_hash(&mut self, director_activity_hash: i32) {
    self.director_activity_hash = Some(director_activity_hash);
  }

  pub fn with_director_activity_hash(mut self, director_activity_hash: i32) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.director_activity_hash = Some(director_activity_hash);
    self
  }

  pub fn director_activity_hash(&self) -> Option<&i32> {
    self.director_activity_hash.as_ref()
  }

  pub fn reset_director_activity_hash(&mut self) {
    self.director_activity_hash = None;
  }

  pub fn set_instance_id(&mut self, instance_id: i64) {
    self.instance_id = Some(instance_id);
  }

  pub fn with_instance_id(mut self, instance_id: i64) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.instance_id = Some(instance_id);
    self
  }

  pub fn instance_id(&self) -> Option<&i64> {
    self.instance_id.as_ref()
  }

  pub fn reset_instance_id(&mut self) {
    self.instance_id = None;
  }

  pub fn set_mode(&mut self, mode: Object) {
    self.mode = Some(mode);
  }

  pub fn with_mode(mut self, mode: Object) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.mode = Some(mode);
    self
  }

  pub fn mode(&self) -> Option<&Object> {
    self.mode.as_ref()
  }

  pub fn reset_mode(&mut self) {
    self.mode = None;
  }

  pub fn set_modes(&mut self, modes: Vec<::models::DestinyHistoricalStatsDefinitionsDestinyActivityModeType>) {
    self.modes = Some(modes);
  }

  pub fn with_modes(mut self, modes: Vec<::models::DestinyHistoricalStatsDefinitionsDestinyActivityModeType>) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.modes = Some(modes);
    self
  }

  pub fn modes(&self) -> Option<&Vec<::models::DestinyHistoricalStatsDefinitionsDestinyActivityModeType>> {
    self.modes.as_ref()
  }

  pub fn reset_modes(&mut self) {
    self.modes = None;
  }

  pub fn set_is_private(&mut self, is_private: bool) {
    self.is_private = Some(is_private);
  }

  pub fn with_is_private(mut self, is_private: bool) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.is_private = Some(is_private);
    self
  }

  pub fn is_private(&self) -> Option<&bool> {
    self.is_private.as_ref()
  }

  pub fn reset_is_private(&mut self) {
    self.is_private = None;
  }

}



