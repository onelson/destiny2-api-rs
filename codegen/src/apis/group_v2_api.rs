/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use std::rc::Rc;
use std::borrow::Borrow;

use hyper;
use serde_json;
use futures;
use futures::{Future, Stream};

use super::{Error, configuration};

pub struct GroupV2ApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> GroupV2ApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> GroupV2ApiClient<C> {
        GroupV2ApiClient {
            configuration: configuration,
        }
    }
}

pub trait GroupV2Api {
    fn group_v2_abdicate_foundership(&self, founder_id_new: i64, group_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20014, Error = Error>>;
    fn group_v2_add_optional_conversation(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse2007, Error = Error>>;
    fn group_v2_approve_all_pending(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20025, Error = Error>>;
    fn group_v2_approve_pending_for_list(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20025, Error = Error>>;
    fn group_v2_ban_member(&self, group_id: i64, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>>;
    fn group_v2_create_group(&self, ) -> Box<Future<Item = ::models::InlineResponse20019, Error = Error>>;
    fn group_v2_deny_all_pending(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20025, Error = Error>>;
    fn group_v2_deny_pending_for_list(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20025, Error = Error>>;
    fn group_v2_edit_clan_banner(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>>;
    fn group_v2_edit_founder_options(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>>;
    fn group_v2_edit_group(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>>;
    fn group_v2_edit_group_membership(&self, group_id: i64, membership_id: i64, membership_type: i32, member_type: i32) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>>;
    fn group_v2_edit_optional_conversation(&self, conversation_id: i64, group_id: i64) -> Box<Future<Item = ::models::InlineResponse2007, Error = Error>>;
    fn group_v2_get_admins_and_founder_of_group(&self, currentpage: i32, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20020, Error = Error>>;
    fn group_v2_get_available_avatars(&self, ) -> Box<Future<Item = ::models::InlineResponse20012, Error = Error>>;
    fn group_v2_get_available_themes(&self, ) -> Box<Future<Item = ::models::InlineResponse20013, Error = Error>>;
    fn group_v2_get_banned_members_of_group(&self, currentpage: i32, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20022, Error = Error>>;
    fn group_v2_get_group(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20017, Error = Error>>;
    fn group_v2_get_group_by_name(&self, group_name: &str, group_type: i32) -> Box<Future<Item = ::models::InlineResponse20017, Error = Error>>;
    fn group_v2_get_group_optional_conversations(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20018, Error = Error>>;
    fn group_v2_get_groups_for_member(&self, filter: i32, group_type: i32, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20026, Error = Error>>;
    fn group_v2_get_invited_individuals(&self, currentpage: i32, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20024, Error = Error>>;
    fn group_v2_get_members_of_group(&self, currentpage: i32, group_id: i64, member_type: i32, name_search: &str) -> Box<Future<Item = ::models::InlineResponse20020, Error = Error>>;
    fn group_v2_get_pending_memberships(&self, currentpage: i32, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20024, Error = Error>>;
    fn group_v2_get_potential_groups_for_member(&self, filter: i32, group_type: i32, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20027, Error = Error>>;
    fn group_v2_get_recommended_groups(&self, ) -> Box<Future<Item = ::models::InlineResponse20016, Error = Error>>;
    fn group_v2_get_user_clan_invite_setting(&self, m_type: i32) -> Box<Future<Item = ::models::InlineResponse20014, Error = Error>>;
    fn group_v2_group_search(&self, ) -> Box<Future<Item = ::models::InlineResponse20016, Error = Error>>;
    fn group_v2_individual_group_invite(&self, group_id: i64, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20023, Error = Error>>;
    fn group_v2_individual_group_invite_cancel(&self, group_id: i64, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20023, Error = Error>>;
    fn group_v2_kick_member(&self, group_id: i64, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20021, Error = Error>>;
    fn group_v2_request_group_membership(&self, group_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20023, Error = Error>>;
    fn group_v2_rescind_group_membership(&self, group_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20021, Error = Error>>;
    fn group_v2_set_user_clan_invite_setting(&self, allow_invites: bool, m_type: i32) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>>;
    fn group_v2_unban_member(&self, group_id: i64, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>>;
}


impl<C: hyper::client::Connect>GroupV2Api for GroupV2ApiClient<C> {
    fn group_v2_abdicate_foundership(&self, founder_id_new: i64, group_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20014, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Admin/AbdicateFoundership/{membershipType}/{founderIdNew}/", configuration.base_path, founderIdNew=founder_id_new, groupId=group_id, membershipType=membership_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20014, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_add_optional_conversation(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse2007, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/OptionalConversations/Add/", configuration.base_path, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse2007, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_approve_all_pending(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20025, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/ApproveAll/", configuration.base_path, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20025, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_approve_pending_for_list(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20025, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/ApproveList/", configuration.base_path, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20025, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_ban_member(&self, group_id: i64, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Ban/", configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20015, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_create_group(&self, ) -> Box<Future<Item = ::models::InlineResponse20019, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/Create/", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20019, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_deny_all_pending(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20025, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/DenyAll/", configuration.base_path, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20025, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_deny_pending_for_list(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20025, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/DenyList/", configuration.base_path, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20025, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_edit_clan_banner(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/EditClanBanner/", configuration.base_path, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20015, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_edit_founder_options(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/EditFounderOptions/", configuration.base_path, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20015, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_edit_group(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Edit/", configuration.base_path, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20015, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_edit_group_membership(&self, group_id: i64, membership_id: i64, membership_type: i32, member_type: i32) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/SetMembershipType/{memberType}/", configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type, memberType=member_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20015, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_edit_optional_conversation(&self, conversation_id: i64, group_id: i64) -> Box<Future<Item = ::models::InlineResponse2007, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/OptionalConversations/Edit/{conversationId}/", configuration.base_path, conversationId=conversation_id, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse2007, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_admins_and_founder_of_group(&self, currentpage: i32, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20020, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/GroupV2/{groupId}/AdminsAndFounder/", configuration.base_path, currentpage=currentpage, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20020, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_available_avatars(&self, ) -> Box<Future<Item = ::models::InlineResponse20012, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/GroupV2/GetAvailableAvatars/", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20012, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_available_themes(&self, ) -> Box<Future<Item = ::models::InlineResponse20013, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/GroupV2/GetAvailableThemes/", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20013, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_banned_members_of_group(&self, currentpage: i32, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20022, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/GroupV2/{groupId}/Banned/", configuration.base_path, currentpage=currentpage, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20022, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_group(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20017, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/GroupV2/{groupId}/", configuration.base_path, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20017, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_group_by_name(&self, group_name: &str, group_type: i32) -> Box<Future<Item = ::models::InlineResponse20017, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/GroupV2/Name/{groupName}/{groupType}/", configuration.base_path, groupName=group_name, groupType=group_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20017, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_group_optional_conversations(&self, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20018, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/GroupV2/{groupId}/OptionalConversations/", configuration.base_path, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20018, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_groups_for_member(&self, filter: i32, group_type: i32, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20026, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/GroupV2/User/{membershipType}/{membershipId}/{filter}/{groupType}/", configuration.base_path, filter=filter, groupType=group_type, membershipId=membership_id, membershipType=membership_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20026, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_invited_individuals(&self, currentpage: i32, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20024, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/InvitedIndividuals/", configuration.base_path, currentpage=currentpage, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20024, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_members_of_group(&self, currentpage: i32, group_id: i64, member_type: i32, name_search: &str) -> Box<Future<Item = ::models::InlineResponse20020, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("memberType", &member_type.to_string())
            .append_pair("nameSearch", &name_search.to_string())
            .finish();
        let uri_str = format!("{}/GroupV2/{groupId}/Members/{}", configuration.base_path, query, currentpage=currentpage, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20020, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_pending_memberships(&self, currentpage: i32, group_id: i64) -> Box<Future<Item = ::models::InlineResponse20024, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/Pending/", configuration.base_path, currentpage=currentpage, groupId=group_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20024, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_potential_groups_for_member(&self, filter: i32, group_type: i32, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20027, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/GroupV2/User/Potential/{membershipType}/{membershipId}/{filter}/{groupType}/", configuration.base_path, filter=filter, groupType=group_type, membershipId=membership_id, membershipType=membership_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20027, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_recommended_groups(&self, ) -> Box<Future<Item = ::models::InlineResponse20016, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/Recommended/", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20016, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_get_user_clan_invite_setting(&self, m_type: i32) -> Box<Future<Item = ::models::InlineResponse20014, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/GroupV2/GetUserClanInviteSetting/{mType}/", configuration.base_path, mType=m_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20014, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_group_search(&self, ) -> Box<Future<Item = ::models::InlineResponse20016, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/Search/", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20016, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_individual_group_invite(&self, group_id: i64, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20023, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/IndividualInvite/{membershipType}/{membershipId}/", configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20023, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_individual_group_invite_cancel(&self, group_id: i64, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20023, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/IndividualInviteCancel/{membershipType}/{membershipId}/", configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20023, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_kick_member(&self, group_id: i64, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20021, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Kick/", configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20021, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_request_group_membership(&self, group_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20023, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/Apply/{membershipType}/", configuration.base_path, groupId=group_id, membershipType=membership_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20023, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_rescind_group_membership(&self, group_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20021, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/Rescind/{membershipType}/", configuration.base_path, groupId=group_id, membershipType=membership_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20021, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_set_user_clan_invite_setting(&self, allow_invites: bool, m_type: i32) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/SetUserClanInviteSetting/{mType}/{allowInvites}/", configuration.base_path, allowInvites=allow_invites, mType=m_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20015, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn group_v2_unban_member(&self, group_id: i64, membership_id: i64, membership_type: i32) -> Box<Future<Item = ::models::InlineResponse20015, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Unban/", configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::InlineResponse20015, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

}
